<?php

/**
 * @file calculates statistics
 */

function sentiment_stat_menu() {
      $items['admin/config/services/stat'] = array(
    'title' => 'Sentiment Stat Test',
    'description' => t('Test stat generation'),
    'page callback' => array('sentiment_stat_calculate'),
    'access arguments' => array('administer site configuration'),
  );
        return $items;
}

/**
 * Keeps values for calculation.
 */
function sentiment_stat_values() {
    $tables = array(
        'sentiment_analyzer' => array(
            'elated',
            'depressed',
            'confused',
            'clearheaded',
            'anxious',
            'composed',
            'tired',
            'energetic',
            'hostile',
            'agreeable',
        ),
        'stockinfo_exchange' => array(
            'stockinfo_exchange_close',
            'stockinfo_exchange_high',
            'stockinfo_exchange_low',
        ),
    );
    return $tables;
}

/**
 * 
 */

function sentiment_stat_calculate() {
      db_delete("{sentiment_stat}")
      ->execute();
    $tables = sentiment_stat_values();
    foreach ($tables as $table => $fields) {
        foreach($fields as $field) {
    $mean_init = 0;
    $sa = db_select($table, "tb")
    ->fields("tb", array($field, "date"))
    ->execute()
    ->fetchAll();
    foreach($sa as $number) {
        $mean_init = $mean_init + $number->$field;
    }
    $mean = $mean_init / count($sa);
    watchdog("sa", "<pre>" . print_r($sa, true) . "</pre>");
    watchdog("mean", "<pre>" . print_r($mean, true) . "</pre>");
    $variance_init = 0;
    foreach($sa as $number) {
        $variance_init = $variance_init + pow(($number->$field - $mean), 2);
    }
    $variance = $variance_init / count($sa);
    watchdog("variance", "<pre>" . print_r($variance, true) . "</pre>");
    $std = sqrt($variance);
    watchdog("std", "<pre>" . print_r($std, true) . "</pre>");
    $zscore_array = array();
    foreach($sa as $number) {
        $zscore = ($number->$field - $mean) / $std;
        $zscore_array[] = $zscore;
        db_insert("sentiment_stat")
        ->fields(
                array(
                    // Change field to some combo of field at some point soon
                    "type" => $field,
                    "category" => "feeling",
                    "mean" => $mean,
                    "std" => $std,
                    "variance" => $variance,
                    "zscore" => $zscore,
                    "date" => $number->date,
                    )
                )->execute();
    }
    watchdog("zscore", "<pre>" . print_r($zscore_array, true) . "</pre>");
    }
    }
    sentiment_stat_corr("hostile", "stockinfo_exchange_close");
}

function sentiment_stat_corr($field1, $field2) {
    $date = 1439769600;
    $x = db_select("sentiment_stat", "tb")
    ->fields("tb", array("zscore", "date"))
            ->condition('type', $field1,'=')
            ->condition('date', $date, '>')
    ->execute()
    ->fetchAll();
    
    $y = db_select("sentiment_stat", "tb")
    ->fields("tb", array("zscore", "date"))
            ->condition('type', $field2,'=')
            ->condition('date', $date, '>')
    ->execute()
    ->fetchAll();
    
        watchdog("x", "<pre>" . print_r($x, true) . "</pre>");
    watchdog("y", "<pre>" . print_r($y, true) . "</pre>");
    
    sentiment_stat_process_weekends($x, $y);
    
    $days = array(0, 1, 2, 3, 4);
    
    foreach($days as $day) {
    
    $x = array_slice($x, 0, (len($x) - $day));
    $y = array_slice($y, $day);
    
    watchdog("x", "<pre>" . print_r($x, true) . "</pre>");
    watchdog("y", "<pre>" . print_r($y, true) . "</pre>");
    
    $regression = sentiment_stat_linear_regression($x, $y);
    watchdog("regression", "<pre>" . print_r($regression, true) . "</pre>");
    }
}

/**
 * Responsible for figuring out what days are weekends/holidays.
 */
function sentiment_stat_process_weekends(&$x, &$y, $interpolate = true) {
    if($interpolate == true) {
        sentiment_stat_change_date($x, true);
        sentiment_stat_change_date($y);
            watchdog("y date", "<pre>" . print_r($y, true) . "</pre>");
                watchdog("x date", "<pre>" . print_r($x, true) . "</pre>");
    if(len($x) > len($y)) {
        sentiment_stat_add_days($x, $y);
    }
    else if(len($y) > len($x)) {
        sentiment_stat_add_days($x, $y);
    }
    }
    else if($interpolate == false) {
        
    }
}

function sentiment_stat_add_days($longer, $shorter) {
    foreach($shorter as $short) {
        
    }
}

function sentiment_stat_change_date(&$values, $collected) {
    // If the value is collected, it may be collected a few hours too late.
    $correction = 0;
    if($collected == true) {
        $correction = 21600;
    }
    foreach($values as $value) {
        $value->date = date("m-d", $value->date - $correction);
    }
}

/**
 * linear regression function
 * @param $x array x-coords
 * @param $y array y-coords
 * @returns array() m=>slope, b=>intercept
 */
function sentiment_stat_linear_regression($x, $y) {

  // calculate number points
  $n = count($x);
  
  // ensure both arrays of points are the same size
  if ($n != count($y)) {

    watchdog("Linear Regression", "Number of elements in coordinate arrays do not match.");
  
  }

  // calculate sums
  $x_sum = array_sum($x);
  $y_sum = array_sum($y);

  $xx_sum = 0;
  $xy_sum = 0;
  
  for($i = 0; $i < $n; $i++) {
  
    $xy_sum+=($x[$i]*$y[$i]);
    $xx_sum+=($x[$i]*$x[$i]);
    
  }
  
  // calculate slope
  $m = (($n * $xy_sum) - ($x_sum * $y_sum)) / (($n * $xx_sum) - ($x_sum * $x_sum));
  
  // calculate intercept
  $b = ($y_sum - ($m * $x_sum)) / $n;
    
  // return result
  return array("m"=>$m, "b"=>$b);

}

/**
 * Implements hook_views_api().
 */
function sentiment_stat_views_api()
{
    return array(
        'api' => 3,
        'path' => drupal_get_path('module', 'sentiment_stat') . '/views',
    );
}